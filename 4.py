# Инициализация вводных данных
N, M = [int(x) for x in input().split()]
m = [int(x) for x in input().split()]

# Инициализируем нулями двумерный массив минимальных количеств предметов размером "кол-во предметов N" x "требуемый вес M"
dp = [[0] * (M + 1) for _ in range(N + 1)]

for i in range(1, N + 1): # Проходим во всем возможным предметам
    for j in range(1, M + 1): # Проходим по всем возможным единицам веса до требуемого
        if m[i - 1] == j:
            dp[i][j] = 1 # ставим количество = 1, если вес текущего предмета равен текущему перебираемому весу
        elif m[i - 1] > j:
            dp[i][j] = dp[i - 1][j] # ставим количество равное значению количеств из предыдущей итерации (предмета), если текущий предмет тяжелее текущего перебираемого веса
        else: # иначе, т.е. если вес текущего предмета меньше, чем текущее перебираемое значение веса
            dp[i][j] = dp[i - 1][j] # предварительно также инициализируем значением из предыдущей итерации (предмета)
            if (dp[i - 1][j - m[i - 1]] + 1) > 1: # если получается, что с данным предметом можно получить количество более 1 ("новое" значение), то обновляем текущее значение:
                # минимум из предыдущего и "нового", если предыдущее не было 0. В таком случае просто "новое" запишем, чтобы минимум не забил всё нулями...
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - m[i - 1]] + 1) if (dp[i - 1][j] != 0) else dp[i - 1][j - m[i - 1]] + 1

# Выводим значение количества предметов для последнего значения массива, т.е. после обхода всех предметов и на максимальной сумме (что требовалось в задаче)..
print(dp[N][M])
